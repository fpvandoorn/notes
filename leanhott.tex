\documentclass{llncs}

\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{amssymb,color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.1, 0.2, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
%% \lstset{language=lean}
\lstset{language=lean,breakatwhitespace}

\newcommand{\fa}[2]{\ensuremath{\mathrm{\Pi}(#1),\ #2}}
\newcommand{\fax}[2]{\ensuremath{\mathrm{\Pi}#1,\ #2}}
\newcommand{\ex}[2]{\ensuremath{\mathrm{\Sigma}(#1),\ #2}}
\newcommand{\empt}{\ensuremath{\mathbf{0}}}
\newcommand{\unit}{\ensuremath{\mathbf{1}}}
\newcommand{\bool}{\ensuremath{\mathbf{2}}}
\newcommand{\myap}{\textnormal{ap}}
\newcommand{\myapd}{\textnormal{apd}}
\newcommand{\base}{\textnormal{base}}
\newcommand{\lp}{\textnormal{loop}}
\newcommand{\rec}{\textnormal{rec}}
\newcommand{\refl}{\textnormal{refl}}
\newcommand{\idpo}{\textnormal{idpo}}
\newcommand{\quotient}{\textnormal{quotient}}
\newcommand{\inl}{\textnormal{inl}}
\newcommand{\inr}{\textnormal{inr}}
\newcommand{\ct}{\cdot}
\newcommand{\inv}{^{-1}}
\newcommand{\UU}{\mathcal{U}}

\usepackage[hidelinks,bookmarksdepth=2]{hyperref}

\begin{document}

\title{Homotopy Type Theory in Lean}

\author{Ulrik Buchholtz\inst{1}
  \and Floris van Doorn\inst{1}
  \and Jakob von Raumer\inst{2}}

\institute{Carnegie Mellon University
  \and University of Nottingham}

\maketitle

\begin{abstract}
  (We discuss the homotopy type theory library in Lean)
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Example code snippets:
\begin{lstlisting}
variables {A : Type} {B : A → Type} {C : Πa, B a → Type}
definition sigma_transport {a₁ a₂ : A} (p : a₁ = a₂)
  (x : Σ(b : B a₁), C a₁ b) : p ▸ x = ⟨p ▸ x.1, p ▸D x.2⟩ :=
by induction p; induction x; reflexivity
\end{lstlisting}

% gobble specifies the number of spaces which should be removed at the start of every line
\begin{lstlisting}[gobble=2]
  definition sigma_assoc_comm_equiv {A : Type} (B C : A → Type)
    : (Σ(v : Σa, B a), C v.1) ≃ (Σ(u : Σa, C a), B u.1) :=
  calc
    (Σ(v : Σa, B a), C v.1)
        ≃ (Σa (b : B a), C a)     : sigma_assoc_equiv
    ... ≃ (Σa (c : C a), B a)     : sigma_equiv_sigma_right
                                      (λa, !comm_equiv_nondep)
    ... ≃ (Σ(u : Σa, C a), B u.1) : sigma_assoc_equiv
\end{lstlisting}

\begin{lstlisting}[gobble=2]
  variable (P : S¹ → Type)
  definition circle.rec_unc (v : Σ(p : P base), p =[loop] p)
    : Π(x : S¹), P x :=
  begin
    intro x, induction v with p q, induction x,
    { exact p},
    { exact q}
  end

  definition circle_pi_equiv
    : (Π(x : S¹), P x) ≃ Σ(p : P base), p =[loop] p :=
  begin
    fapply equiv.MK,
    { intro f, exact ⟨f base, apd f loop⟩},
    { exact circle.rec_unc P},
    { intro v, induction v with p q, fapply sigma_eq,
      { reflexivity},
      { esimp, apply pathover_idp_of_eq, apply rec_loop}},
    { intro f, apply eq_of_homotopy, intro x, induction x,
      { reflexivity},
      { apply eq_pathover_dep, apply hdeg_squareover, esimp, apply rec_loop}}
  end
\end{lstlisting}
% If a character doesn't appear, add it to lstlean.tex
% TODO: maybe don't display Σ and Π in italics?

\subsection{Homotopy Type Theory}
\label{sec:hott}

\section{The Lean Proof Assistant}
\label{sec:lean}

\cite{Moura2015}

(type theory, two kernel modes, emacs mode, open source, etc.)

kernel: universes, function types, inductive types (2 HITs)

elaborator: inferring implicit arguments, type class inference, coercions, tactic language

Future of Lean: with/without HoTT

new version of lean: no more higher order unification, write custom tactics

\section{The Structure of the Library}
\label{sec:library}

% Ulrik TODO

\section{Path Algebra and Cubical Methods}
\label{sec:cubical}

% higher coherence lemmas (?)
% parallel composition etc (?)
% a few lemmas about pathovers?

The core innovation in Homotopy Type theory is its new interpretation of equality.
In contrast to proof irrelevant Martin-L\"of Type Theory, we need to be careful about
choosing well-behaved equality proofs in the library since we might need to prove
lemmas about these proof objects themselves.
We want to maintain brevity using tactics and equational rewriting while making sure
that the generated proofs don't become unwieldy.

After defining equality on a type $A$ in the library's prelude as an inductive
type family over two objects of $A$ which is generated by the reflexivity witness
$\refl : \fa{x : A}{x = x}$, we can provide operations and proofs for the basic
\emph{groupoid structure} of these ``equality paths'':
Concatenation $p \ct q$ and inversion $p\inv$ of paths as well as proofs about
associativity and cancellation.
These are constructed using the dependent recursor of equality which we call \emph{path
 induction} and which, for each $a : A$, provides a function $\fa{b : A, p : a = b} P(b, p)$
given the reflexivity case $P(a, \refl_a)$.
Likewise, we can prove the functoriality of functions with respect to equality:
For a function $f : A \to B$ and $p : a = a'$ we define $\myap_f(p) : f(a) = f(a')$ by
induction on $p$.
Using an equality $p : a = a'$ in a type $A$ to compare elements of two fibers in
a type family $C$ over $A$, we define the \emph{transport} of an element $x : C(a)$
along $p$ as $p^*(x) : C(a')$.

In many Homotopy Type Theory libraries as well as in the HoTT book \cite{hottbook},
the transport is used to introduce the notion of a \emph{heterogeneous equality},
comparing elements $x : C(a)$ and $y : C(a')$ in different fibers of a type family
by first transporting along some equality $p : a = a'$ in the base:
$$
\left(x =_p^C y\right) :\equiv \left(p^*(x) = y\right)
$$
Instead of pursuing this approach we instead chose to follow what Dan Licata calls
the ``cubical approach''~\cite{LicataBrunerie2015} to heterogeneous equalities.
The core of this approach is the definition of a \emph{pathover}.
The above definition of what can be seen as a ``path over a path'' is replaced by
an equivalent one:
We define the type of pathovers over a base point $a : A$ and $x : C(a)$ to be the
type family $x =_\_^C \_ : \fa{a' : A}{a = a' \to C(a') \to \UU}$ which is inductively generated
by
$$
\idpo : b =_{\refl_a}^C b \textnormal{.}
$$
This definition allows us to define a version $\myapd_f(p) : f(a) =_p^C f(a')$ of
$\myap$ for dependent functions $f : \fa{a : A}{C(a)}$.
It is also used by Lean to express the dependent eliminators for higher inductive
types (c.\,f. section~\ref{sec:hits}).
To work with pathovers we provide a variety of operations and lemmas:
We define the concatenation and inversion of pathovers over concatenated paths,
resp. inverted paths, as well as groupoid laws for these operations, as pathovers
over the corresponding groupoid laws for the homogeneous equality. %TODO

In order to prove (homogeneous and heterogeneous) equalities between equalities
and pathovers themselves, we generalize both notions to square and squareovers:
Just like paths were defined as an inductive type family indexed by their endpoints
we define the squares in a certain type $A$ as the type family indexed by four corners
and four ``edges'' between those corners, which is generated by some identity
square with $\refl$ on all its sides.
And like for pathovers we introduce a ``dependent'' version where the type of
corners and sides varies along some type family.


\section{Higher Inductive Types}
\label{sec:hits}

One novel idea in Homotopy Type Theory is the introduction of \emph{higher inductive types} or
HITs. Higher inductive types are a generalization of inductive types. With inductive types you can
specify which terms or points are freely added to that type. In contrast, when defining a HIT, you
can specify not only the points in that type, but also paths and higher paths. For example, the
circle $S^1$ is a HIT with one point constructor and one path constructor, generated by:
\begin{itemize}
  \item $\base : S^1$
  \item $\lp : \base = \base$
\end{itemize}
Like every inductive type, a higher inductive type has an \emph{elimination principle} or
\emph{induction principle} which states the data one has to provide to define a (dependent) function
out of the HIT. For the circle, the induction principle states that in order to define a function $f
: \fa{x : S^1}{P(x)}$ one has to define $f$ on the basepoint and specify its behavior on $\lp$. This
means one has to give a point $p : P(\base)$ and a dependent path $q : p =_\lp^Pp$, which is a
dependent path over $\lp$. This data defines a function $\rec_{S^1}(p,q) : \fa{x : S^1}{P(x)}$ with
the following computation rules $\rec_{S^1}(p,q,\base)\equiv p$ and
$\myapd_{\rec_{S^1}(p,q)}(\lp)=q$ where $\myapd$ is the action of a dependent function on paths. The
first computation rule is a judgmental equality, but the second computation rule only posits an
inhabitant of the identity type. In general: the computation rules on point constructors are always
judgmental equalities, but the computation rules for (higher) path constructors are not.\footnote{In
  newer \emph{cubical} type theories the computation rules for path constructors also hold
  judgmentally.\cite{cohen2015cubical}}
% mention cubical type theory here?

Using the Univalence Axiom, you can prove that $\lp \neq \refl_\base$, which means the circle is not
just the unit type.

The most commonly used dependently typed proof assistants like Coq and Agda don't support HITs. In
order to reason about HITs in a proof assistant one has to encode them in some way. The most naive
thing would be to add everything as constants/axioms. This has one huge disadvantage, which is that
the computation rules on point constructors is not a judgmental equality anymore. This has as a
consequence that the user has to transport terms along these equalities. For instance, in our
example of the circle, the type $\myapd_{\rec_{S^1}(p,q)}(\lp)=q$ is not type correct if the
computation rule on the point constructor is not a definitional equality, since the left-hand side
has type $\rec_{S^1}(p,q,\base) =_\lp^P \rec_{S^1}(p,q,\base)$ while the right-hand side has type $p
=_\lp^Pp$.

Instead, the method to reason about HITs uses a method called ``Dan Licata's
trick''~\cite{Licata2011trick}. The idea is that to define a higher inductive type, one first
defines a private inductive type inside a section with only the point constructors, and then adds
the path constructors as axioms. Then one defines the desired induction principle using the
induction principle of the private inductive type and add the computation rule of this induction
principle on paths as additional axioms. Then the user closes the section, and the result is that
only the data of the higher inductive type are accessible, while the induction principle of the
private inductive type is hidden. One major advantage of this method is that the computation rules
are definitionally true for point constructors, but a disadvantage is that inside the section
inconsistent axioms were assumed.

In Lean we reason about inductive types differently.  We take two higher inductive types as
primitive, namely the $n$-truncation and the (typal) quotient. The quotient is the following
HIT. Given a type $A$ and a type-valued relation $R : A \to A \to \UU$ we freely add the elements of
$R$ as equalities to $A$:
\begin{itemize}
  \item $i : A \to \quotient_A(R)$
  \item $e : \fa{x y : A}{R(x,y) \to i(x)=i(y)}$
\end{itemize}
So for example $S^1$ is the quotient where $A:\equiv\unit$ and $R(\star,\star):\equiv\unit$.

For the $n$-truncation and the quotient, we add the type formation rule, point and path
constructors, and induction principle as constants/axioms.\footnote{For the $n$ truncation we treat
  the fact that the new type is $n$-truncated as a ``path-constructor.'' In
  \cite[Section~7.3]{hottbook} it is explained that the fact that a type is $n$-truncated can be
  reduced to (recursive) path constructors.} Then we add the computation rules for the point
constructors to the Lean kernel; the Lean kernel is extensible in such a way that certain new
computation rules can be added to it. After that, we add the computation rules on paths as axioms.

Given these two HITs, we continue to define other HITs in terms of these. In fact, all other HITs in
the Lean HoTT library are defined just using these two HITs. Some reductions are simple, for example
the (homotopy) pushout of $f : A \to B$ and $g : A \to C$ is the quotient on type $B+C$ with the
relation $R$ defined as an inductive family with constructor $\fa{a : A}
{R(\inl(f(a)),\inr(g(a)))}$. Proving the usual induction principle for the pushout is then
trivial. Given the pushout, we have defined the other usual HITs: the suspension, circle, join,
smash, wedge, cofiber, mapping cylinder and spheres.

However, we can do more. We can define HITs with 2-path constructors using quotients. This uses a
method similar to the hubs-and-spokes method described in \cite[Section~6.7]{hottbook}. Note that
for any path $p : x =_A x$ we can define a map $f:S^1\to A$ with $\myap_f{\lp}=p$ by circle
induction. Then we can prove the equivalence $(p = \refl_{x})\simeq \ex{x_0 : A}{\fa{z :
    S^1}{f(z)=x_0}}$. This equivalence can be informally states as that filling in a loop (an
element of $p=\refl_{x}$) is the same as adding a new point $x_0$, the \emph{hub}, and \emph{spokes}
$f(z)=x_0$ for every $z : S^1$, similar to the spokes in a wheel.


\section{Examples}
\label{sec:examples}

\subsection{Category Theory}
The Yoneda embedding preserves existing limits.
\begin{lstlisting}[gobble=2]
  definition yoneda_embedding (C : Precategory) : C ⇒ cset ^c Cᵒᵖ

  variables {C D : Precategory}
  definition preserves_existing_limits [class] (G : C ⇒ D) :=
  Π(I : Precategory) (F : I ⇒ C)
    [H : has_terminal_object (cone F)],
    is_terminal (cone_obj_compose G (terminal_object (cone F)))

  theorem preserves_existing_limits_yoneda_embedding
    (C : Precategory)
    : preserves_existing_limits (yoneda_embedding C)
\end{lstlisting}

Rezk completion (Jakob)

\subsection{Homotopy theory}

LES of homotopy groups

van Kampen

Hopf, incl. complex and quaternionic

\section{Conclusion}
\label{sec:conclusion}

In the future, the HoTT mode of Lean will probably be adapted to work
with a version of cubical type theory.

Follow the progress of the library on the Lean GitHub wiki:

Cite \cite{bauer2016coqhott}

\bibliographystyle{splncs03}
\bibliography{leanhott}
\end{document}
